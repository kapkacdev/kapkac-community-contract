#include "stdlib.fc";

;; ============= Constants =============
;; Operation codes
const op::request_referral = 0x525246;       ;; "RRF" in hex
const op::accept_referral = 0x415246;        ;; "ARF" in hex
const op::register_driver = 0x52444956;      ;; "RDRV" in hex
const op::register_passenger = 0x52505347;   ;; "RPSG" in hex
const op::start_ride = 0x53524944;           ;; "SRID" in hex
const op::end_ride = 0x45524944;             ;; "ERID" in hex
const op::verify_ride = 0x56524944;          ;; "VRID" in hex
const op::start_sprint = 0x53535052;         ;; "SSPR" in hex
const op::submit_proposal = 0x53505250;      ;; "SPRP" in hex
const op::vote = 0x564F5445;                 ;; "VOTE" in hex
const op::stake = 0x53544B45;                ;; "STKE" in hex
const op::unstake = 0x554E5354;              ;; "UNST" in hex
const op::emergency_pause = 0x45504155;      ;; "EPAU" in hex
const op::emergency_unpause = 0x45554E50;    ;; "EUNP" in hex
const op::create_subcommunity = 0x43535542;  ;; "CSUB" in hex


;; Token constants
const TOKEN_DRIVER_REFERENCE_BONUS = 100;          ;; KAC tokens for driver referral
const TOKEN_MIN_MEMBER_HOLD = 1;                   ;; Min KAC to be member
const TOKEN_MIN_PASSENGER_HOLD = 5;                ;; Min KAC to be passenger
const TOKEN_MIN_VOTING_HOLD = 10;                  ;; Min KAC to vote
const TOKEN_MIN_DRIVER_HOLD = 1000;                ;; Min KAC to be driver
const TOKEN_EMERGENCY_PROPOSAL_THRESHOLD = 10000;   ;; KAC needed for emergency proposal

;; Referral constrants
const REFERRAL_REQUEST_VALIDITY = 86400;   ;; 24 hours in seconds

;; Trust tier constants
const TRUST_BRONZE_THRESHOLD = 299;
const TRUST_SILVER_THRESHOLD = 499;
const TRUST_GOLD_THRESHOLD = 699;
const TRUST_PLATINUM_THRESHOLD = 899;
const TRUST_DIAMOND_THRESHOLD = 1000;

;; Trust tier multipliers (in basis points, 100 = 1%)
const TRUST_BRONZE_MULTIPLIER = 80;    ;; 0.8x
const TRUST_SILVER_MULTIPLIER = 90;    ;; 0.9x
const TRUST_GOLD_MULTIPLIER = 100;     ;; 1.0x
const TRUST_PLATINUM_MULTIPLIER = 110;  ;; 1.1x
const TRUST_DIAMOND_MULTIPLIER = 120;   ;; 1.2x

;; Fee reductions by tier (in basis points)
const TRUST_BRONZE_FEE_REDUCTION = 0;     ;; 0%
const TRUST_SILVER_FEE_REDUCTION = 500;   ;; 5%
const TRUST_GOLD_FEE_REDUCTION = 1000;    ;; 10%
const TRUST_PLATINUM_FEE_REDUCTION = 1500; ;; 15%
const TRUST_DIAMOND_FEE_REDUCTION = 2000;  ;; 20%

;; Ride constants
const RIDE_BASE_FARE = 50;              ;; Base fare in TRY
const RIDE_KM_RATE = 30;                ;; Per km rate in TRY
const RIDE_MINUTE_RATE = 10;            ;; Per minute rate in TRY

;; Traffic multipliers (in basis points)
const RIDE_LIGHT_TRAFFIC_MULTIPLIER = 100;    ;; 1.0x
const RIDE_MODERATE_TRAFFIC_MULTIPLIER = 120;  ;; 1.2x
const RIDE_HEAVY_TRAFFIC_MULTIPLIER = 140;     ;; 1.4x
const RIDE_SEVERE_TRAFFIC_MULTIPLIER = 160;    ;; 1.6x

;; Time modifiers (in basis points)
const RIDE_STANDARD_TIME_MODIFIER = 100;   ;; 1.0x (09:00-16:00)
const RIDE_PEAK_TIME_MODIFIER = 130;       ;; 1.3x (07:00-09:00, 16:00-19:00)
const RIDE_NIGHT_TIME_MODIFIER = 125;      ;; 1.25x (23:00-05:00)
const RIDE_OFF_PEAK_MODIFIER = 100;        ;; 1.0x (all other times)

;; Price protection
const RIDE_MAX_PRICE_MULTIPLIER = 250;     ;; 2.5x maximum
const RIDE_MIN_PRICE_MULTIPLIER = 80;      ;; 0.8x minimum

;; Status constants
const RIDE_REQUESTED = 1;
const RIDE_STARTED = 2;
const RIDE_COMPLETED = 3;
const RIDE_CANCELLED = 4;

const SPRINT_ACTIVE = 1;
const SPRINT_ENDED = 2;

const PROPOSAL_ACTIVE = 1;
const PROPOSAL_PASSED = 2;
const PROPOSAL_FAILED = 3;
const PROPOSAL_EXECUTED = 4;

;; Governance constants
const GOVERNANCE_VOTING_PERIOD = 259200;            ;; 3 days in seconds
const GOVERNANCE_MIN_QUORUM = 1000;                 ;; 10% in basis points
const GOVERNANCE_SUCCESS_THRESHOLD = 6600;          ;; 66% in basis points
const GOVERNANCE_EMERGENCY_THRESHOLD = 7500;        ;; 75% in basis points
const GOVERNANCE_PARAMETER_CHANGE_DELAY = 172800;   ;; 48 hours
const GOVERNANCE_EMERGENCY_DELAY = 43200;           ;; 12 hours

;; ============= Storage Variables =============
global cell members;            ;; Members registry
global cell rides;              ;; Rides registry
global cell trust_scores;       ;; Trust scores
global cell sprints;            ;; Sprints registry
global cell proposals;          ;; Governance proposals
global cell current_params;     ;; Current system parameters
global cell subcommunities;     ;; Sub-communities
global slice owner_address;     ;; Platform owner address
global int current_sprint_id;   ;; Active sprint ID
global int system_paused;       ;; Emergency pause flag
global cell pending_referrals;  ;; Dictionary of address -> (requester, timestamp)

;; ============= Storage Operations =============
() load_data() impure {
    slice ds = get_data().begin_parse();
    if (ds.slice_empty?()) {
        members = new_dict();
        rides = new_dict();
        trust_scores = new_dict();
        sprints = new_dict();
        proposals = new_dict();
        current_params = new_dict();
        subcommunities = new_dict();
        pending_referrals = new_dict();
        system_paused = 0;
        current_sprint_id = 0;
        owner_address = my_address();
        return ();
    }

    owner_address = ds~load_msg_addr();
    members = ds~load_dict();
    rides = ds~load_dict();
    trust_scores = ds~load_dict();
    sprints = ds~load_dict();
    proposals = ds~load_dict();
    current_params = ds~load_dict();
    subcommunities = ds~load_dict();
    pending_referrals = ds~load_dict();
    system_paused = ds~load_uint(1);
    current_sprint_id = ds~load_uint(32);
}
() save_data() impure {
    set_data(
        begin_cell()
            .store_slice(owner_address)
            .store_dict(members)
            .store_dict(rides)
            .store_dict(trust_scores)
            .store_dict(sprints)
            .store_dict(proposals)
            .store_dict(current_params)
            .store_dict(subcommunities)
            .store_dict(pending_referrals)    ;; Add this line
            .store_uint(system_paused, 1)
            .store_uint(current_sprint_id, 32)
        .end_cell()
    );
}


;; ============= Referral System =============
int is_valid_member(slice address) {
    (cell member_data, int success) = members.udict_get_ref?(256, slice_hash(address));
    return success;
}

int calculate_trust_score(int ride_points, int stake_points) {
    ;; Calculate based on 50-50 weight as per whitepaper
    int ride_score = min(500, (ride_points * 500) / 500);  ;; Max 500 points from rides
    int stake_score = min(500, (stake_points * 500) / 1000); ;; Max 500 points from staking
    return min(1000, ride_score + stake_score);
}

(int, int) get_trust_score(slice address) method_id {
    load_data();
    (cell score_data, int success) = trust_scores.udict_get_ref?(256, slice_hash(address));
    if (~ success) {
        return (0, 0);
    }
    
    slice score = score_data.begin_parse();
    int ride_points = score~load_uint(32);
    int stake_points = score~load_uint(32);
    int total_rides = score~load_uint(32);
    
    return (calculate_trust_score(ride_points, stake_points), total_rides);
}


() handle_request_referral(slice sender_address, slice in_msg_body) impure {
    ;; Verify sender doesn't exist as member
    throw_if(709, is_valid_member(sender_address));
    
    ;; Get referrer address
    slice referrer = in_msg_body~load_msg_addr();
    
    ;; Verify referrer is valid member with minimum trust score
    throw_unless(708, is_valid_member(referrer));
    (int trust_score, _) = get_trust_score(referrer);
    throw_unless(710, trust_score >= 100);  ;; Minimum trust score to be referrer
    
    ;; Store referral request
    cell request_data = begin_cell()
        .store_slice(sender_address)     ;; requester
        .store_uint(now(), 64)           ;; request time
    .end_cell();
    
    pending_referrals~udict_set_ref(256, slice_hash(referrer), request_data);
    save_data();
}

() handle_accept_referral(slice sender_address, slice in_msg_body) impure {
    ;; Get requester data
    (cell request_data, int success) = pending_referrals.udict_get_ref?(256, slice_hash(sender_address));
    throw_unless(711, success);
    
    slice request = request_data.begin_parse();
    slice requester = request~load_msg_addr();
    int request_time = request~load_uint(64);
    
    ;; Check if request is still valid
    throw_unless(712, (now() - request_time) <= REFERRAL_REQUEST_VALIDITY);
    
    ;; Clear the request
    pending_referrals~udict_delete?(256, slice_hash(sender_address));
    
    ;; Add referral count to referrer's data
    (cell referrer_data, int ref_success) = members.udict_get_ref?(256, slice_hash(sender_address));
    if (ref_success) {
        slice referrer = referrer_data.begin_parse();
        int referral_count = referrer~load_uint(32);
        
        cell new_referrer_data = begin_cell()
            .store_uint(referral_count + 1, 32)  ;; Increment referral count
            .store_slice(referrer)               ;; Rest of the data
        .end_cell();
        
        members~udict_set_ref(256, slice_hash(sender_address), new_referrer_data);
    }
    
    ;; Send reward to referrer
    var msg = begin_cell()
        .store_uint(0x18, 6)
        .store_slice(sender_address)
        .store_coins(TOKEN_DRIVER_REFERENCE_BONUS)
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
        .store_uint(0, 32)
    .end_cell();
    
    send_raw_message(msg, 1);
    save_data();
}


;; ============= Trust Score System =============
(int, int) get_trust_tier(int score) {
    if (score <= TRUST_BRONZE_THRESHOLD) {
        return (TRUST_BRONZE_MULTIPLIER, TRUST_BRONZE_FEE_REDUCTION);
    }
    if (score <= TRUST_SILVER_THRESHOLD) {
        return (TRUST_SILVER_MULTIPLIER, TRUST_SILVER_FEE_REDUCTION);
    }
    if (score <= TRUST_GOLD_THRESHOLD) {
        return (TRUST_GOLD_MULTIPLIER, TRUST_GOLD_FEE_REDUCTION);
    }
    if (score <= TRUST_PLATINUM_THRESHOLD) {
        return (TRUST_PLATINUM_MULTIPLIER, TRUST_PLATINUM_FEE_REDUCTION);
    }
    return (TRUST_DIAMOND_MULTIPLIER, TRUST_DIAMOND_FEE_REDUCTION);
}

;; ============= Dynamic Pricing System =============
int get_time_modifier(int timestamp) impure {
    ;; Extract hour from timestamp (0-23)
    int hour = (timestamp / 3600) % 24;
    
    ;; Convert hour to fixed-point representation for comparison
    int current_hour = hour + 0; ;; Ensure int type
    
    ;; Peak hours: 7-9 AM and 4-7 PM
    if (((current_hour >= 7) & (current_hour < 9)) | ((current_hour >= 16) & (current_hour < 19))) {
        return RIDE_PEAK_TIME_MODIFIER;
    }
    
    ;; Night hours: 11 PM - 5 AM
    if ((current_hour >= 23) | (current_hour < 5)) {
        return RIDE_NIGHT_TIME_MODIFIER;
    }
    
    ;; Standard hours: 9 AM - 4 PM
    if ((current_hour >= 9) & (current_hour < 16)) {
        return RIDE_STANDARD_TIME_MODIFIER;
    }
    
    ;; Off-peak for remaining hours
    return RIDE_OFF_PEAK_MODIFIER;
}

int calculate_ride_price(int distance, int duration, int traffic_multiplier, int trust_score) {
    int base_price = RIDE_BASE_FARE + 
                    (RIDE_KM_RATE * distance) + 
                    (RIDE_MINUTE_RATE * duration);
    
    int time_mod = get_time_modifier(now());
    (int trust_multiplier, int fee_reduction) = get_trust_tier(trust_score);
    
    ;; Apply multipliers (in basis points)
    int total_multiplier = (traffic_multiplier * time_mod) / 100;
    total_multiplier = max(RIDE_MIN_PRICE_MULTIPLIER, 
                          min(RIDE_MAX_PRICE_MULTIPLIER, total_multiplier));
    
    ;; Calculate final price with fee reduction
    int price_with_multiplier = (base_price * total_multiplier) / 100;
    return (price_with_multiplier * (10000 - fee_reduction)) / 10000;
}

(cell, int) calculate_qualified_drivers(int start_time, int end_time, int min_rides) impure {
    cell qualified_drivers = new_dict();
    int driver_count = 0;
    
    ;; Iterate through rides
    int key = -1;
    do {
        (key, slice cs, int found) = rides.udict_get_next?(256, key);
        if (found) {
            slice ride = cs;
            int ride_time = ride~load_uint(64);
            
            if ((ride_time >= start_time) & (ride_time <= end_time)) {
                slice driver_address = ride~load_msg_addr();
                
                ;; Count rides per driver
                (cell driver_stats, int driver_found) = qualified_drivers.udict_get_ref?(256, slice_hash(driver_address));
                if (driver_found) {
                    slice stats = driver_stats.begin_parse();
                    int current_rides = stats~load_uint(32);
                    if ((current_rides + 1) >= min_rides) {
                        driver_count += 1;
                    }
                    qualified_drivers~udict_set_builder(
                        256,
                        slice_hash(driver_address),
                        begin_cell()
                            .store_uint(current_rides + 1, 32)
                            .store_slice(driver_address)
                    );
                } else {
                    qualified_drivers~udict_set_builder(
                        256,
                        slice_hash(driver_address),
                        begin_cell()
                            .store_uint(1, 32)
                            .store_slice(driver_address)
                    );
                }
            }
        }
    } until (~ found);
    
    return (qualified_drivers, driver_count);
}

() distribute_sprint_rewards(int sprint_id) impure {
    (cell sprint_data, int success) = sprints.udict_get_ref?(256, sprint_id);
    throw_unless(901, success);
    
    slice sprint = sprint_data.begin_parse();
    int start_time = sprint~load_uint(64);
    int end_time = sprint~load_uint(64);
    int total_rides = sprint~load_uint(32);
    int total_rewards = sprint~load_coins();
    int status = sprint~load_uint(8);
    
    ;; Calculate qualified drivers
    int min_rides_required = total_rides / 10; ;; 10% of total rides to qualify
    (cell qualified_drivers, int driver_count) = calculate_qualified_drivers(start_time, end_time, min_rides_required);
    
    ;; If no qualified drivers, save rewards for next sprint
    if (driver_count == 0) {
        return ();
    }
    
    ;; Calculate base reward per driver
    int base_reward = total_rewards / driver_count;
    
    ;; Distribute rewards based on trust score multipliers
    int key = -1;
    do {
        (key, slice cs, int found) = qualified_drivers.udict_get_next?(256, key);
        if (found) {
            slice driver_stats = cs;
            int rides_completed = driver_stats~load_uint(32);
            slice driver_address = driver_stats~load_msg_addr();
            
            ;; Get trust score and calculate multiplier
            (cell score_data, int score_success) = trust_scores.udict_get_ref?(256, slice_hash(driver_address));
            if (score_success) {
                slice score = score_data.begin_parse();
                int ride_points = score~load_uint(32);
                int stake_points = score~load_uint(32);
                int trust_score = calculate_trust_score(ride_points, stake_points);
                
                ;; Get multiplier based on trust tier
                (int multiplier, _) = get_trust_tier(trust_score);
                
                ;; Calculate final reward with trust multiplier
                int final_reward = (base_reward * multiplier) / 100;
                
                ;; Send reward to driver
                var msg = begin_cell()
                    .store_uint(0x18, 6)
                    .store_slice(driver_address)
                    .store_coins(final_reward)
                    .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
                    .store_uint(0, 32)
                .end_cell();
                
                send_raw_message(msg, 1);
            }
        }
    } until (~ found);
}

;; ============= Sprint System =============
() send_referral_rewards(slice ref1, slice ref2) impure {
    ;; Build message for first referrer
    var msg1 = begin_cell()
        .store_uint(0x18, 6)           ;; nobounce
        .store_slice(ref1)             ;; destination address
        .store_coins(TOKEN_DRIVER_REFERENCE_BONUS / 2)  ;; value in nanotons
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)    ;; clear all flags and state
        .store_uint(0, 32)             ;; opcode 0
    .end_cell();

    ;; Build message for second referrer
    var msg2 = begin_cell()
        .store_uint(0x18, 6)           ;; nobounce
        .store_slice(ref2)             ;; destination address
        .store_coins(TOKEN_DRIVER_REFERENCE_BONUS / 2)  ;; value in nanotons
        .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)    ;; clear all flags and state
        .store_uint(0, 32)             ;; opcode 0
    .end_cell();


    ;; Send both messages
    send_raw_message(msg1, 1);  ;; mode 1 - pay fees separately
    send_raw_message(msg2, 1);  ;; mode 1 - pay fees separately
}

() handle_register_driver(slice sender_address, int msg_value, slice in_msg_body) impure {
    throw_unless(707, msg_value >= TOKEN_MIN_DRIVER_HOLD);
    
    ;; Load referrer addresses from message body
    slice ref1 = in_msg_body~load_msg_addr();  ;; use load_msg_addr() for address slices
    slice ref2 = in_msg_body~load_msg_addr();
    
    ;; Verify referrers are valid members
    throw_unless(708, is_valid_member(ref1));
    throw_unless(708, is_valid_member(ref2));
    
    ;; Verify sender doesn't exist
    throw_if(709, is_valid_member(sender_address));
    
    ;; Store driver data
    cell driver_data = begin_cell()
        .store_slice(sender_address)
        .store_uint(1, 1)  ;; is_referred
        .store_uint(0, 1)  ;; is_verified (needs verification)
        .store_uint(0, 1)  ;; is_banned
        .store_uint(0, 1)  ;; is_hold
        .store_uint(1, 8)  ;; role = driver
        .store_uint(now(), 64)  ;; registration_time
    .end_cell();
    
    members~udict_set_ref(256, slice_hash(sender_address), driver_data);
    
    ;; Initialize trust score
    cell trust_data = begin_cell()
        .store_uint(0, 32)  ;; ride_points
        .store_uint(0, 32)  ;; stake_points
        .store_uint(0, 32)  ;; total_rides
        .store_coins(msg_value)     ;; staking_amount
        .store_uint(now(), 64)  ;; staking_time
    .end_cell();
    
    trust_scores~udict_set_ref(256, slice_hash(sender_address), trust_data);
    
    ;; Send referral rewards with proper slice handling
    send_referral_rewards(ref1, ref2);
    
    save_data();
}

() handle_register_passenger(slice sender_address, int msg_value, slice in_msg_body) impure {
    throw_unless(707, msg_value >= TOKEN_MIN_PASSENGER_HOLD);
    
    ;; Check reference
    slice ref1 = in_msg_body~load_msg_addr();
    throw_unless(708, is_valid_member(ref1));
    
    ;; Verify sender doesn't exist
    throw_if(709, is_valid_member(sender_address));
    
    ;; Store passenger data
    cell passenger_data = begin_cell()
        .store_slice(sender_address)
        .store_uint(1, 1)  ;; is_referred
        .store_uint(1, 1)  ;; is_verified (auto-verified for passengers)
        .store_uint(0, 1)  ;; is_banned
        .store_uint(0, 1)  ;; is_hold
        .store_uint(2, 8)  ;; role = passenger
        .store_uint(now(), 64)  ;; registration_time
    .end_cell();
    
    members~udict_set_ref(256, slice_hash(sender_address), passenger_data);
    save_data();
}

() handle_start_ride(slice sender_address, int msg_value, slice in_msg_body) impure {
    ;; Verify sender is a valid passenger
    throw_unless(801, is_valid_member(sender_address));
    
    slice driver_address = in_msg_body~load_msg_addr();
    int distance = in_msg_body~load_uint(32);
    int duration = in_msg_body~load_uint(32);
    int traffic_multiplier = in_msg_body~load_uint(16);
    
    throw_unless(802, is_valid_member(driver_address));
    
    ;; Calculate ride price
    (int trust_score, _) = get_trust_score(driver_address);
    int calculated_price = calculate_ride_price(distance, duration, traffic_multiplier, trust_score);
    throw_unless(803, msg_value >= calculated_price);
    
    ;; Create unique ride ID
    int ride_id = slice_hash(
        begin_cell()
            .store_slice(sender_address)
            .store_slice(driver_address)
            .store_uint(now(), 64)
        .end_cell()
        .begin_parse()
    );
    
    ;; Store ride data
    cell ride_data = begin_cell()
        .store_slice(driver_address)
        .store_slice(sender_address)
        .store_uint(now(), 64)          ;; start_time
        .store_uint(0, 64)              ;; end_time
        .store_uint(distance, 32)       ;; distance
        .store_uint(duration, 32)       ;; duration
        .store_coins(calculated_price)   ;; amount
        .store_uint(RIDE_STARTED, 8)    ;; status
        .store_uint(traffic_multiplier, 16)  ;; traffic_multiplier
        .store_uint(get_time_modifier(now()), 16)  ;; time_modifier
    .end_cell();
    
    rides~udict_set_ref(256, ride_id, ride_data);
    save_data();
}



;; ============= Get Methods =============
(int, slice, int) get_member_data(slice address) {
    (cell member_data, int success) = members.udict_get_ref?(256, slice_hash(address));
    if (~ success) {
        return (0, null(), 0);
    }
    slice member_slice = member_data.begin_parse();
    slice member_copy = member_slice; ;; Create a copy for returning
    int role = member_slice~load_uint(8);
    return (1, member_copy, role);
}

(slice, int, int) get_member_details(slice address) method_id {
    load_data();
    (int exists, slice member_data, int role) = get_member_data(address);
    if (~ exists) {
        return (null(), 0, 0);
    }
    
    return (member_data, role, now());
}

(int, _, int) get_member_info(slice address) method_id {
    (int exists, slice member_data, int role) = get_member_data(address);
    if (~ exists) {
        return (0, 0, 0);
    }
    int is_verified = member_data~load_uint(1);
    int is_banned = member_data~load_uint(1);
    return (role, is_verified, is_banned);
}


(int, cell) get_ride_history(slice address, int start_time, int end_time) method_id {
    load_data();
    cell ride_history = new_dict();
    int ride_count = 0;
    
    ;; Iterate through rides
    int key = -1;
    do {
        (key, slice cs, int found) = rides.udict_get_next?(256, key);
        if (found) {
            slice ride = cs;
            slice driver = ride~load_msg_addr();
            slice passenger = ride~load_msg_addr();
            int ride_time = ride~load_uint(64);
            
            if ((ride_time >= start_time) & 
                (ride_time <= end_time) & 
                (equal_slice_bits(driver, address) | equal_slice_bits(passenger, address))) {
                
                ;; Store ride data in a new cell
                cell ride_data = begin_cell()
                    .store_slice(driver)
                    .store_slice(passenger)
                    .store_uint(ride_time, 64)
                    .store_uint(ride~load_uint(64), 64)    ;; end_time
                    .store_uint(ride~load_uint(32), 32)    ;; distance
                    .store_uint(ride~load_uint(32), 32)    ;; duration
                    .store_coins(ride~load_coins())        ;; amount
                    .store_uint(ride~load_uint(8), 8)      ;; status
                    .store_uint(ride~load_uint(16), 16)    ;; traffic_multiplier
                    .store_uint(ride~load_uint(16), 16)    ;; time_modifier
                .end_cell();
                
                ride_history~udict_set_ref(256, ride_count, ride_data);
                ride_count += 1;
            }
        }
    } until (~ found);
    
    return (ride_count, ride_history);
}

(int, int, cell) get_earnings_info(slice driver_address, int sprint_id) method_id {
    load_data();
    (cell sprint_data, int success) = sprints.udict_get_ref?(256, sprint_id);
    if (~ success) {
        return (0, 0, null());
    }
    
    slice sprint = sprint_data.begin_parse();
    int start_time = sprint~load_uint(64);
    int end_time = sprint~load_uint(64);
    
    cell earnings_data = new_dict();
    int total_earnings = 0;
    int total_rides = 0;
    
    ;; Calculate earnings for the sprint period
    int key = -1;
    do {
        (key, slice cs, int found) = rides.udict_get_next?(256, key);
        if (found) {
            slice ride = cs;
            slice ride_driver = ride~load_msg_addr();
            int ride_time = ride~load_uint(64);
            
            if ((ride_time >= start_time) & 
                (ride_time <= end_time) & 
                equal_slice_bits(ride_driver, driver_address)) {
                
                ;; Store detailed ride data
                cell ride_data = begin_cell()
                    .store_uint(ride_time, 64)              ;; timestamp
                    .store_uint(ride~load_uint(64), 64)     ;; end_time
                    .store_uint(ride~load_uint(32), 32)     ;; distance
                    .store_uint(ride~load_uint(32), 32)     ;; duration
                    .store_coins(ride~load_coins())         ;; amount
                    .store_uint(ride~load_uint(8), 8)       ;; status
                    .store_uint(ride~load_uint(16), 16)     ;; multipliers
                .end_cell();
                
                total_rides += 1;
                total_earnings += ride~load_coins();
                earnings_data~udict_set_ref(256, total_rides, ride_data);
            }
        }
    } until (~ found);
    
    return (total_earnings, total_rides, earnings_data);
}

cell get_platform_statistics() method_id {
    load_data();
    
    int total_members = 0;
    int total_drivers = 0;
    int total_passengers = 0;
    int total_rides = 0;
    int total_volume = 0;
    
    ;; Calculate member statistics
    int member_key = -1;
    do {
        (member_key, slice cs, int found) = members.udict_get_next?(256, member_key);
        if (found) {
            total_members += 1;
            if (cs.preload_uint(8) == 1) {
                total_drivers += 1;
            } else {
                total_passengers += 1;
            }
        }
    } until (~ found);
    
    ;; Calculate ride statistics
    int ride_key = -1;
    do {
        (ride_key, slice cs, int found) = rides.udict_get_next?(256, ride_key);
        if (found) {
            slice ride = cs;
            total_rides += 1;
            total_volume += ride~load_coins();
        }
    } until (~ found);
    
    return begin_cell()
        .store_uint(total_members, 32)
        .store_uint(total_drivers, 32)
        .store_uint(total_passengers, 32)
        .store_uint(total_rides, 32)
        .store_coins(total_volume)
        .store_uint(current_sprint_id, 32)
        .store_uint(system_paused, 1)
    .end_cell();
}
;; Helper method to get sequence of dict values
(int, slice, int) dict_get_next_item(cell dict, int key) {
    if (key == -1) {
        return dict.udict_get_min?(256);
    }
    return dict.udict_get_next?(256, key);
}

;; ============= Governance System =============
() submit_proposal(slice sender_address, slice in_msg_body) impure {
    ;; Check trust score requirement
    (int trust_score, _) = get_trust_score(sender_address);
    throw_unless(850, trust_score >= 400);
    
    int proposal_type = in_msg_body~load_uint(8);
    if (proposal_type == 2) {  ;; Emergency proposal
        throw_unless(851, trust_score >= 700);
    }
    
    ;; Create proposal
    int proposal_id = slice_hash(
        begin_cell()
            .store_slice(sender_address)
            .store_uint(now(), 64)
        .end_cell()
        .begin_parse()
    );
    
    ;; Load parameter changes as a reference
    cell param_changes = in_msg_body~load_ref();
    
    cell proposal_data = begin_cell()
        .store_slice(sender_address)     ;; proposer
        .store_uint(now(), 64)           ;; creation_time
        .store_uint(proposal_type, 8)    ;; type
        .store_ref(param_changes)        ;; parameter changes - fixed: using store_ref instead of store_cell
        .store_coins(0)                  ;; for_votes
        .store_coins(0)                  ;; against_votes
        .store_uint(PROPOSAL_ACTIVE, 8)  ;; status
    .end_cell();
    
    proposals~udict_set_ref(256, proposal_id, proposal_data);
    save_data();
}

(int, int, int) get_dynamic_price_info(int distance, int duration) method_id {
    load_data();
    int time_mod = get_time_modifier(now());
    int base_price = RIDE_BASE_FARE + (RIDE_KM_RATE * distance) + 
                    (RIDE_MINUTE_RATE * duration);
    return (base_price, time_mod, RIDE_STANDARD_TIME_MODIFIER);
}

cell get_trust_tier_info(int score) method_id {
    (int multiplier, int fee_reduction) = get_trust_tier(score);
    return begin_cell()
        .store_uint(score, 16)
        .store_uint(multiplier, 16)
.store_uint(fee_reduction, 16)
    .end_cell();
}

(int, cell) get_active_sprint_info() method_id {
    load_data();
    if (current_sprint_id == 0) {
        return (0, null());
    }
    (cell sprint_data, int success) = sprints.udict_get_ref?(256, current_sprint_id);
    if (~ success) {
        return (0, null());
    }
    return (current_sprint_id, sprint_data);
}

() start_new_sprint(slice sender_address, slice in_msg_body) impure {
    ;; Verify sender is platform owner or has sufficient trust score
    throw_unless(900, equal_slice_bits(sender_address, owner_address));
    
    ;; End current sprint if exists
    if (current_sprint_id != 0) {
        (cell sprint_data, _) = sprints.udict_get_ref?(256, current_sprint_id);
        slice sprint = sprint_data.begin_parse();
        
        ;; Distribute rewards for current sprint
        distribute_sprint_rewards(current_sprint_id);
    }
    
    ;; Create new sprint
    int new_sprint_id = now();
    cell sprint_data = begin_cell()
        .store_uint(now(), 64)           ;; start_time
        .store_uint(0, 64)               ;; end_time
        .store_uint(0, 32)               ;; total_rides
        .store_coins(0)                  ;; total_rewards
        .store_uint(SPRINT_ACTIVE, 8)    ;; status
    .end_cell();
    
    sprints~udict_set_ref(256, new_sprint_id, sprint_data);
    current_sprint_id = new_sprint_id;
    save_data();
}

;; ============= Sub-community System =============
() create_subcommunity(slice sender_address, slice in_msg_body) impure {
    ;; Verify sender has sufficient trust score
    (int trust_score, _) = get_trust_score(sender_address);
    throw_unless(950, trust_score >= 700);
    
    ;; Create sub-community ID
    int subcommunity_id = slice_hash(
        begin_cell()
            .store_slice(sender_address)
            .store_uint(now(), 64)
        .end_cell()
        .begin_parse()
    );
    
    ;; Initialize sub-community with inherited parameters
    cell subcommunity_data = begin_cell()
        .store_slice(sender_address)         ;; owner
        .store_dict(new_dict())             ;; members
        .store_dict(current_params)          ;; inherited parameters
        .store_uint(0, 32)                   ;; current sprint
        .store_uint(1, 1)                    ;; active status
    .end_cell();
    
    subcommunities~udict_set_ref(256, subcommunity_id, subcommunity_data);
    save_data();
}

() join_subcommunity(slice sender_address, slice in_msg_body) impure {
    int subcommunity_id = in_msg_body~load_uint(256);
    
    ;; Verify sub-community exists
    (cell subcommunity_data, int success) = subcommunities.udict_get_ref?(256, subcommunity_id);
    throw_unless(951, success);
    
    slice subcommunity = subcommunity_data.begin_parse();
    cell members_dict = subcommunity~load_dict();
    
    ;; Add member to sub-community
    members_dict~udict_set_builder(
        256,
        slice_hash(sender_address),
        begin_cell()
            .store_slice(sender_address)
            .store_uint(now(), 64)         ;; join time
            .store_uint(1, 1)              ;; active status
    );
    
    ;; Update sub-community data
    subcommunities~udict_set_ref(
        256,
        subcommunity_id,
        begin_cell()
            .store_slice(subcommunity~load_msg_addr())  ;; owner
            .store_dict(members_dict)
            .store_dict(subcommunity~load_dict())       ;; parameters
            .store_uint(subcommunity~load_uint(32), 32) ;; current sprint
            .store_uint(subcommunity~load_uint(1), 1)   ;; status
        .end_cell()
    );
    
    save_data();
}

;; ============= Emergency Controls =============
() emergency_pause(slice sender_address) impure {
    ;; Only owner or high trust score holders can pause
    throw_unless(970, equal_slice_bits(sender_address, owner_address));
    if (~ equal_slice_bits(sender_address, owner_address)) {
        (int trust_score, _) = get_trust_score(sender_address);
        throw_unless(971, trust_score >= 900);  ;; Diamond tier only
    }
    
    system_paused = 1;
    save_data();
}

() emergency_unpause(slice sender_address) impure {
    throw_unless(972, equal_slice_bits(sender_address, owner_address));
    system_paused = 0;
    save_data();
}

;; ============= Enhanced Security Checks =============
() validate_proposal_parameters(cell param_changes) impure {
    slice params = param_changes.begin_parse();
    
    ;; Verify parameter changes are within allowed ranges
    while (~ params.slice_empty?()) {
        int param_id = params~load_uint(32);
        int new_value = params~load_uint(128);
        
        ;; Get current value
        (cell current_value, int success) = current_params.udict_get_ref?(32, param_id);
        throw_unless(983, success);
        
        ;; Check if change is within 50% limit
        int current = current_value.begin_parse().preload_uint(128);
        int change_ratio = (new_value * 100) / current;
        
        ;; Use bitwise operators for logical AND
        throw_unless(984, (change_ratio >= 50) & (change_ratio <= 150));
    }
}

() validate_ride_parameters(int distance, int duration, int amount) impure {
    throw_unless(980, distance > 0);
    throw_unless(981, duration > 0);
    throw_unless(982, amount >= RIDE_BASE_FARE);
}

() check_member_permissions(slice address, int required_trust_score) impure {
    (int trust_score, _) = get_trust_score(address);
    throw_unless(985, trust_score >= required_trust_score);
}

() check_proposal_requirements(slice proposer_address, int proposal_type) impure {
    (int trust_score, _) = get_trust_score(proposer_address);
    
    if (proposal_type == 1) {  ;; Standard proposal
        throw_unless(986, trust_score >= 400);
    } else {  ;; Emergency proposal
        throw_unless(987, trust_score >= 700);
    }
}

() validate_sprint_parameters(slice in_msg_body) impure {
    int base_fare = in_msg_body~load_uint(128);
    int km_rate = in_msg_body~load_uint(128);
    int minute_rate = in_msg_body~load_uint(128);
    
    ;; Validate base parameters
    throw_unless(988, base_fare >= (RIDE_BASE_FARE / 2));    ;; Can't reduce more than 50%
    throw_unless(988, base_fare <= (RIDE_BASE_FARE * 2));    ;; Can't increase more than 100%
    
    throw_unless(989, km_rate >= (RIDE_KM_RATE / 2));
    throw_unless(989, km_rate <= (RIDE_KM_RATE * 2));
    
    throw_unless(990, minute_rate >= (RIDE_MINUTE_RATE / 2));
    throw_unless(990, minute_rate <= (RIDE_MINUTE_RATE * 2));
    
    ;; Validate multipliers
    int traffic_multiplier = in_msg_body~load_uint(16);
    int time_modifier = in_msg_body~load_uint(16);
    
    ;; Use bitwise AND for multiple conditions
    throw_unless(991, (traffic_multiplier >= RIDE_MIN_PRICE_MULTIPLIER) & 
                     (traffic_multiplier <= RIDE_MAX_PRICE_MULTIPLIER));
    
    throw_unless(992, (time_modifier >= RIDE_MIN_PRICE_MULTIPLIER) & 
                     (time_modifier <= RIDE_MAX_PRICE_MULTIPLIER));
}

() validate_staking_amount(int amount) impure {
    throw_unless(993, amount >= TOKEN_MIN_DRIVER_HOLD);
    throw_unless(994, amount <= TOKEN_MIN_DRIVER_HOLD * 1000);  ;; Maximum stake limit
}

() validate_referral_chain(slice referrer_address) impure {
    (int exists, _, _) = get_member_data(referrer_address);
    throw_unless(995, exists);
    
    ;; Check if referrer is not banned
    (_, _, int is_banned) = get_member_info(referrer_address);
    throw_unless(996, ~ is_banned);
    
    ;; Check referrer's trust score
    (int trust_score, _) = get_trust_score(referrer_address);
    throw_unless(997, trust_score >= 100);  ;; Minimum trust score to refer
}

() validate_ride_completion(int ride_id, slice driver_address) impure {
    (cell ride_data, int success) = rides.udict_get_ref?(256, ride_id);
    throw_unless(998, success);
    
    slice ride = ride_data.begin_parse();
    slice ride_driver = ride~load_msg_addr();
    
    ;; Verify driver matches
    throw_unless(999, equal_slice_bits(driver_address, ride_driver));
}

() handle_verify_ride(slice sender_address, slice in_msg_body) impure {
    ;; Only backend oracle can verify rides
    throw_unless(805, equal_slice_bits(sender_address, owner_address));
    
    int ride_id = in_msg_body~load_uint(256);
    int distance = in_msg_body~load_uint(32);
    int verified_amount = in_msg_body~load_coins();
    
    (cell ride_data, int ride_success) = rides.udict_get_ref?(256, ride_id);
    throw_unless(806, ride_success);
    
    slice ride = ride_data.begin_parse();
    slice driver_address = ride~load_msg_addr();
    slice passenger_address = ride~load_msg_addr();
    
    ;; Update trust scores
    (cell driver_score, int score_success) = trust_scores.udict_get_ref?(256, slice_hash(driver_address));
    throw_unless(807, score_success);
    
    slice score = driver_score.begin_parse();
    int ride_points = score~load_uint(32);
    
    cell new_score = begin_cell()
        .store_uint(ride_points + 1, 32)
        .store_uint(score~load_uint(32), 32)
        .store_uint(score~load_uint(32) + 1, 32)
        .store_coins(score~load_coins())
        .store_uint(score~load_uint(64), 64)
    .end_cell();
    
    trust_scores~udict_set_ref(256, slice_hash(driver_address), new_score);
    save_data();
}

() handle_stake(slice sender_address, int msg_value, slice in_msg_body) impure {
    (cell score_data, int success) = trust_scores.udict_get_ref?(256, slice_hash(sender_address));
    throw_unless(808, success);
    
    slice score = score_data.begin_parse();
    int ride_points = score~load_uint(32);
    int stake_points = score~load_uint(32);
    int total_rides = score~load_uint(32);
    int current_stake = score~load_coins();
    int stake_time = score~load_uint(64);
    
    ;; Update stake data
    cell new_score = begin_cell()
        .store_uint(ride_points, 32)
        .store_uint(stake_points + (msg_value / TOKEN_MIN_DRIVER_HOLD), 32)
        .store_uint(total_rides, 32)
        .store_coins(current_stake + msg_value)
        .store_uint(now(), 64)
    .end_cell();
    
    trust_scores~udict_set_ref(256, slice_hash(sender_address), new_score);
    save_data();
}

;; ============= Main Entry Point =============
() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();
    
    ;; Initialize if empty
    if (get_data().begin_parse().slice_empty?()) {
        owner_address = sender_address;
        members = new_dict();
        rides = new_dict();
        trust_scores = new_dict();
        sprints = new_dict();
        proposals = new_dict();
        current_params = new_dict();
        subcommunities = new_dict();
        system_paused = 0;
        current_sprint_id = 0;
        save_data();
        return ();
    }

    ;; Bounce if message is bounced
    if (flags & 1) {
        return ();
    }

    ;; Load contract data
    load_data();

    ;; Empty message handling
    if (in_msg_body.slice_empty?()) {
        return ();
    }

    ;; Check system pause status (except for emergency controls)
    if (system_paused) {
        int op = in_msg_body~load_uint(32);
        throw_unless(990, op == op::emergency_unpause);
        
        ;; Reset message body position for handler
        in_msg_body = in_msg_full.begin_parse();
        in_msg_body~skip_bits(32 + 64);  ;; Skip flags and sender address
    }

    ;; Process message op
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    ;; Route to appropriate handler
    if (op == op::request_referral) {
        handle_request_referral(sender_address, in_msg_body);
        return ();
    }
    
    if (op == op::accept_referral) {
        handle_accept_referral(sender_address, in_msg_body);
        return ();
    }

    if (op == op::register_driver) {
        handle_register_driver(sender_address, msg_value, in_msg_body);
        return ();
    }
    
    if (op == op::register_passenger) {
        handle_register_passenger(sender_address, msg_value, in_msg_body);
        return ();
    }
    
    if (op == op::start_ride) {
        handle_start_ride(sender_address, msg_value, in_msg_body);
        return ();
    }
    
    if (op == op::verify_ride) {
        handle_verify_ride(sender_address, in_msg_body);
        return ();
    }
    
    if (op == op::stake) {
        handle_stake(sender_address, msg_value, in_msg_body);
        return ();
    }
    
    if (op == op::start_sprint) {
        start_new_sprint(sender_address, in_msg_body);
        return ();
    }
    
    if (op == op::submit_proposal) {
        submit_proposal(sender_address, in_msg_body);
        return ();
    }
    
    if (op == op::create_subcommunity) {
        create_subcommunity(sender_address, in_msg_body);
        return ();
    }
    
    if (op == op::emergency_pause) {
        emergency_pause(sender_address);
        return ();
    }
    
    if (op == op::emergency_unpause) {
        emergency_unpause(sender_address);
        return ();
    }

    throw(0xffff); ;; Unknown operation
}

;; ============= Additional Get Methods =============
(int, cell) get_subcommunity_info(int subcommunity_id) method_id {
    load_data();
    (cell subcommunity_data, int success) = subcommunities.udict_get_ref?(256, subcommunity_id);
    if (~ success) {
        return (0, null());
    }
    return (1, subcommunity_data);
}

(int, int) get_referral_request_status(slice referrer_address) method_id {
    load_data();
    (cell request_data, int success) = pending_referrals.udict_get_ref?(256, slice_hash(referrer_address));
    if (~ success) {
        return (0, 0);
    }
    
    slice request = request_data.begin_parse();
    int request_time = request~load_uint(64);
    return (1, request_time);
}

(int, cell) get_proposal_info(int proposal_id) method_id {
    load_data();
    (cell proposal_data, int success) = proposals.udict_get_ref?(256, proposal_id);
    if (~ success) {
        return (0, null());
    }
    return (1, proposal_data);
}

int get_system_status() method_id {
    load_data();
    return system_paused;
}
